# 1. 前言
1. 商业方面因素，如敏捷开发、测试驱动和对市场机会做出快速反应等，都要求尽量缩短产品开发周期，因此系统中的数据模型也要足够灵活以方便调整。
> 从数据模型的灵活度来考虑软件应对市场/商业的变化。
2. 读完本书之后，你应该会对哪些技术适用于哪些场景，常见工具如何搭配来构建应用系统等有所得。或许你不会马上就决定动手开发一个全新的数据库引擎（这几乎完全不需要），但是，关于系统的本质，相信你一定有新的认识与判断力：系统行为是否合理，架构设计如果权衡，个中症状如何处理等，将会更加游刃有余。
> 阅读本书的目的。

# 1.1 第一部分 数据系统基础
## 1.1.1 可靠、可扩展、可维护的应用系统
1. 故障与失效（ failure ） 不完全一致［2］ 。故障通常被定义为组件偏离其正常规格，而失效意味系统作为一个整体停止，无法向用户提供所需的服务。
2. 通过这种故意引发故障的方式，来持续检验、测试系统的容错机制，增加对真实发生故障时应对的信心。
> 类似企业内部做的容灾演练。
3. 导致软件故｜璋的bug通常会长时间处于引而不发的状态，直到碰到特定的触发条件。这也意味着系统软件其实对使用环境存在某种假设，而这种假设多数情况都可以满足，但是在特定情况下，假设条件变得不再成立。
4. 以最小出错的方式来设计系统。例如，精心设计的抽象层、API 以及管理界面，使“做正确的事情”很轻松，但搞坏很复杂。但是，如果限制过多，人们就会想陆来绕过它，这会抵悄其正面作用。因此解决之道在于很好的平衡。
5. 讨论可扩展性通常要考虑这类问题： “如果系统以某种方式增长，我们应对增长的措施有哪些”， “我们该如何添加计算资据来处理额外的负载” 。
6. 负载可以用称为负载参数的若干数字来描述。参数的最佳选择取决于系统的体系结构，它可能是W e b 服务器的每秒请求处理次数，数据库中写入的比例，聊天室的同时活动用户数量， 缓存命中率等。有时平均值很重要，有时系统瓶颈来自于少数峰值。
7. Twitter扩展性的挑战重点不在
于消息大小，而在于巨大的扇出（ fa n-out ）由结构： 每个用户会关注很多人，也会被很多人圄粉。此时大概有两种处理方案：1. 将发送的新tweet插入到全局的tweet集合中。当用户查看时间线肘，首先查找所有的关注对象，列出这些人的所有tweet ，最后以时间为序来排序合井。2. 对每个用户的时间线维护一个缓存，如图1-3 所示， 类似每个用户一个tweet邮箱。当用户推送新tweet肘，查询其关注者，将tweet插入到每个关注者的时间线缓存中。因为已经预先将结果取出，之后访问时间线性能非常快。
> 推特的设计思路，一个是读扩散，一个是写扩散。至于实际需要哪种方式，按照业务的要求，如果是读大于写，则更侧重于写扩散，如果是写大于读，则更侧重于读扩散。哪个类型的操作多，就应该减少哪个操作所需要耗费的性能或者是时间。
8. 但是， 75这个平均关注者背后还隐藏其他事实，即关注者其实偏差巨大，例如某些用户拥有超过3000 万的追随者。这就意味着峰值情况下一个tweet会导致3000万笔写入！而且要求尽量’快， Twitter的设计目标是Ss 内完成，这成为一个巨大的挑战。
> 要考虑特殊场景下，存在的技术挑战，不要专助于常见的情况。
9. Twitter故事最后的结局是： 方战2 已经得到了稳定实现， Twitter正在转向结合两种方注。大多数用户的tw巳巳t在发布时继续以一对多写入时间线，但是少数具有超多关注者（例如那些名人）的用户除外，对这些用户采用类似方案1 ， 其推文被单独提取，在读取时才和用户的时间线主表合井。
> 两种方案的结合，才是取长补短。
10. 延迟（latency）和响应时间（response time）容易说淆使用，但它们并不完全一样。通常响应时间是客户端看到的：除了处理请求时间（服务时间，service time）外，还包括来回网络延迟和各种排队延迟。延迟则是请求花费在处理上的时间。
11. 我们经常考察的是服务请求的平均响应时间（严格来说，术语“平均值”并没有明确采用何种具体公式，但通常被理解为算术平均值：给定n个值，将所有值相加，井除以n ） 。然而，如果想知道更典型的响应时－间，平均值并不是合适的指标，因为它掩盖了一些信息，无能告诉有多少用户实际经历了多少延迟。因此最好使用百分位数（ percen ti Jes ） 。如果已经搜集到了响应时间信息，将其从最快到最慢排序，中位数（ median ）就是列表中间的响应时间。例如，如果中位数响应时间为200 ms ，那意味着有一半的请求响应不到200 ms ，而另一半请求则需要更长的时间。
> 平均响应时间往往掩盖了一些特殊情况，所在与客户签订合同时，最适合的方式是保证多少个百分位的响应时间在多少范围以内，这种情况既能给服务的响应时间定一个范围，又能避免在一些无法控制的情况下，留有一定的空间。
12. 首先，针对特定级别负载而设计的架构不太可能应付超出预设目标10倍的实际负载。如果目标服务处于快速增长阶段，那么需要认真考虑每增加一个数量级的负载，架构应如何设计。 
13. 在多台机器上分配负载也被称为无共享体系结构。在单台机器上运行的系统通常更简单，然而高端机器可能非常昂贵，且扩展水平有限，最终往往还是无法避免需要水平扩展。
> 当前架构可支撑的情况下，如果要考虑后续业务的提升，那么在水平扩展的场景下，各个组件应该如何设计，能够保证可持续的扩展？
14. 把无状态服务分布然后扩展至多台机器相对比较容易，而有状态服务从单个节点扩展到分布式多机环境的复杂性会大大增加。
> 说的就是13点的问题，当有状态时，就不能无限制的做扩展。
15. 消除意外复杂性最好手段之一是抽象。一个好的设计抽象可以隐藏大量的实现细节，并对外提供干净、易懂的接口。
16. 如果应用数据具有类似文档的结构（即一对多关系树，通常**一次加载整个树**） ， 那么使用文档模型更为合适。**而关系型模型则倾向于某种数据分解，它把文档结构分解为多个表**，有可能使得模式更为笨重，以及不必要的应用代码复杂化。
17. 如果应用程序需要频繁访问整个文档（例如，在网页上呈现它）， 则存储局部性具有性能优势。如果数据被划分在多个表中，则需要进行多次索引查找来检索所有数据，中间可能需要更多的磁盘1/0井花费更多的时间。
> 存储局部性，就是把相关内容都存储在一起，这里面更侧重于数据存储在磁盘中的一个小范围内，确保查询数据时，能一次性都拿出来。
