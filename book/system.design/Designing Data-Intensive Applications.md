# 1. 前言
1. 商业方面因素，如敏捷开发、测试驱动和对市场机会做出快速反应等，都要求尽量缩短产品开发周期，因此系统中的数据模型也要足够灵活以方便调整。
> 从数据模型的灵活度来考虑软件应对市场/商业的变化。
2. 读完本书之后，你应该会对哪些技术适用于哪些场景，常见工具如何搭配来构建应用系统等有所得。或许你不会马上就决定动手开发一个全新的数据库引擎（这几乎完全不需要），但是，关于系统的本质，相信你一定有新的认识与判断力：系统行为是否合理，架构设计如果权衡，个中症状如何处理等，将会更加游刃有余。
> 阅读本书的目的。

# 1.1 第一部分 数据系统基础
## 1.1.1 可靠、可扩展、可维护的应用系统
1. 故障与失效（ failure ） 不完全一致［2］ 。故障通常被定义为组件偏离其正常规格，而失效意味系统作为一个整体停止，无法向用户提供所需的服务。
2. 通过这种故意引发故障的方式，来持续检验、测试系统的容错机制，增加对真实发生故障时应对的信心。
> 类似企业内部做的容灾演练。
3. 导致软件故｜璋的bug通常会长时间处于引而不发的状态，直到碰到特定的触发条件。这也意味着系统软件其实对使用环境存在某种假设，而这种假设多数情况都可以满足，但是在特定情况下，假设条件变得不再成立。
4. 以最小出错的方式来设计系统。例如，精心设计的抽象层、API 以及管理界面，使“做正确的事情”很轻松，但搞坏很复杂。但是，如果限制过多，人们就会想陆来绕过它，这会抵悄其正面作用。因此解决之道在于很好的平衡。
5. 讨论可扩展性通常要考虑这类问题： “如果系统以某种方式增长，我们应对增长的措施有哪些”， “我们该如何添加计算资据来处理额外的负载” 。
6. 负载可以用称为负载参数的若干数字来描述。参数的最佳选择取决于系统的体系结构，它可能是W e b 服务器的每秒请求处理次数，数据库中写入的比例，聊天室的同时活动用户数量， 缓存命中率等。有时平均值很重要，有时系统瓶颈来自于少数峰值。
7. Twitter扩展性的挑战重点不在
于消息大小，而在于巨大的扇出（ fa n-out ）由结构： 每个用户会关注很多人，也会被很多人圄粉。此时大概有两种处理方案：1. 将发送的新tweet插入到全局的tweet集合中。当用户查看时间线肘，首先查找所有的关注对象，列出这些人的所有tweet ，最后以时间为序来排序合井。2. 对每个用户的时间线维护一个缓存，如图1-3 所示， 类似每个用户一个tweet邮箱。当用户推送新tweet肘，查询其关注者，将tweet插入到每个关注者的时间线缓存中。因为已经预先将结果取出，之后访问时间线性能非常快。
> 推特的设计思路，一个是读扩散，一个是写扩散。至于实际需要哪种方式，按照业务的要求，如果是读大于写，则更侧重于写扩散，如果是写大于读，则更侧重于读扩散。哪个类型的操作多，就应该减少哪个操作所需要耗费的性能或者是时间。
8. 但是， 75这个平均关注者背后还隐藏其他事实，即关注者其实偏差巨大，例如某些用户拥有超过3000 万的追随者。这就意味着峰值情况下一个tweet会导致3000万笔写入！而且要求尽量’快， Twitter的设计目标是Ss 内完成，这成为一个巨大的挑战。
> 要考虑特殊场景下，存在的技术挑战，不要专助于常见的情况。
